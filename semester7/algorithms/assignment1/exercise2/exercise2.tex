\newpage

\subsubsection*{Άσκηση 2}

Μπορούμε να αναπαραστίσουμε ένα δέντρο με τη χρήση ενός πίνακα A, με το στοιχείο $A[i]$ να έχει αριστερό και δεξί παιδί τα στοιχεία $Α[2i]$ και $Α[2i+1]$ αντίστοιχα.
Ένα στοιχείο $A[i]$ αναπαριστά σωρό αν $A[2i], A[2i+1]$ είναι μικρότερα και αναπαριστούν επίσης σωρό. 
Μπορούμε να ορίσουμε τον αλγόριθμο \en{heapify(A,i)} όπου αν τα στοιχεία $A[2i]$, $A[2i+1]$ αναπαριστούν σωρούς, τότε ο πίνακας αλλάζει κατάλληλα ετσι ώστε και το $A[i]$ 
να αναπαριστά σωρό. 

Ορισμός του \en{heapify},

\selectlanguage{english}
\begin{minted}{text}
    def heapify(A,i)
        left <- 2*i
        right <- 2*i + 1
        largest <- 1
        if left <= heap_length(A) and A[left] > A[largest] then
            largest <- left
        if right <= heap_length(A) and A[right] > A[largest] then
            largest <- right
        if largest != i then
            swap(A[i], A[largest])
            heapify(A, largest)
\end{minted}
\selectlanguage{greek}

Ο \en{heapify} έχει πολυπλοκότητα $O(h)$ όπου $h$ το ύψος του $A[i]$ στο αναπαριστόμενο δέντρο του πίνακα.
Για να φτιάξουμε έναν σωρό απο έναν πίνακα $A$, μπορούμε να εκτελέσουμε συνεχόμενα τον \en{heapify} για κάθε κόμβο ανα επίπεδο αρχίζοντας απο τα χαμηλότερα επίπεδα.
Αφού για ύψος $h$ έχουμε το πολύ $\frac{n}{2^h}$ κόμβους, συνολικά το κόστος της δημιουργίας του σωρού θα είναι $\sum_{h=0}^{\log n} \frac{n}{2^h}O(h) = O(n\sum_{k=0}^{\log n} \frac{h}{2^h}) = O(n)$.
Η ένωση των δύο σωρών επομένως μπορεί να γίνει αντιγράφοντας τους δύο σωρούς σε έναν τρίτο πίνακα που θα περιέχει όλα τα στοιχεία και μετά εκτελώντας τον παραπάνω αλγόριθμο έτσι ώστε να μετατραπεί σε σωρό.
Συνολικά θα έχουμε το κόστος των αντιγραφών και του αλγόριθμου δημιουργίας και επομένως η πολυπλοκότητα θα έιναι γραμμική στον αριθμό των συνολικών στοιχείων των σωρών.


